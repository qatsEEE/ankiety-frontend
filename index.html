<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Ankieta z Tłem Stars</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"/>

  <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@8.0.0/dist/browser/signalr.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/tsparticles@3/tsparticles.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tsparticles/preset-stars@3/tsparticles.preset.stars.bundle.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background-color: #000;
      color: #fff;
      /* overflow-x: hidden; */ /* Only prevent horizontal scroll if needed, vertical is usually fine */
      /* overflow: hidden; can sometimes cut off content if it exceeds viewport height */
    }
    #tsparticles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0; /* Place behind other content */
    }
    #app-container {
      position: relative; /* Ensure it's above tsParticles */
      z-index: 1; /* Higher z-index than #tsparticles */
      max-width: 700px;
      margin: 5vh auto; /* 5% viewport height margin top/bottom, auto for horizontal centering */
      background: rgba(0,0,0,0.7); /* Semi-transparent background for readability */
      padding: 2rem;
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(255,255,255,0.1);
    }
    h1 {
      text-align: center;
      margin-bottom: 2rem;
    }
    .option {
      margin: 1rem 0;
      background: rgba(255,255,255,0.05);
      padding: 1rem;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .option:hover {
      background: rgba(255,255,255,0.15);
    }
    .bar-container {
      background: rgba(255,255,255,0.1);
      height: 8px;
      border-radius: 5px;
      margin-top: 0.5rem;
    }
    .bar {
      height: 100%;
      border-radius: 5px;
      background: linear-gradient(to right, #00f2ff, #0055ff); /* Gradient for the vote bar */
      width: 0; /* Initial width */
      transition: width 0.3s ease; /* Smooth transition for width change */
    }
  </style>
</head>
<body>
  <div id="tsparticles"></div>

  <div id="app-container">
    <h1>Ankieta: Ulubiona Marka Samochodu</h1>
    <div id="poll-container">Ładowanie...</div>
  </div>

  <script>
    // Initialize tsParticles with the stars preset
    // This script block is moved to the end of <body> for better reliability
    (async () => {
      // It's good practice to ensure tsParticles is loaded before attempting to use it
      if (typeof tsParticles !== 'undefined' && typeof loadStarsPreset !== 'undefined') {
        await loadStarsPreset(tsParticles);
        await tsParticles.load("tsparticles", {
          preset: "stars",
          fullScreen: { enable: true, zIndex: 0 } // Ensures full screen and correct layering
        });
        console.log("tsParticles stars background initialized.");
      } else {
        console.error("tsParticles or loadStarsPreset not loaded correctly.");
      }
    })();

    // API URL for your poll backend
    const apiUrl = "https://ankietyapi-da.azurewebsites.net/api";

    const container = document.getElementById("poll-container");
    let currentPollData = null; // Stores the current state of the poll

    // Fetches poll data and renders options
    async function fetchAndRenderPoll() {
      try {
        const resp = await fetch(`${apiUrl}/polls/1`); // Fetching poll with ID 1
        if (!resp.ok) {
          container.innerHTML = `<p>Nie znaleziono ankiety.</p>`;
          console.error(`Failed to fetch poll: ${resp.status} ${resp.statusText}`);
          return;
        }
        currentPollData = await resp.json();
        renderOptions(); // Render the options once data is fetched
      } catch (err) {
        container.innerHTML = `<p>Błąd ładowania danych.</p>`;
        console.error("Error fetching poll data:", err);
      }
    }

    // Renders or re-renders the poll options and vote percentages
    function renderOptions() {
      if (!currentPollData) return;

      const totalVotes = currentPollData.Options.reduce((sum, opt) => sum + opt.Votes, 0);
      let html = "";
      currentPollData.Options.forEach(opt => {
        const percentage = totalVotes ? ((opt.Votes / totalVotes) * 100).toFixed(1) : 0;
        html += `
          <div class="option" onclick="vote(${opt.Id})" id="opt-${opt.Id}">
            <strong>${opt.Text}</strong>
            <div>${opt.Votes} głosów (${percentage}%)</div>
            <div class="bar-container"><div class="bar" style="width:${percentage}%"></div></div>
          </div>`;
      });
      container.innerHTML = html;
    }

    // Handles a vote for a specific option
    async function vote(optionId) {
      const optionElement = document.getElementById(`opt-${optionId}`);
      if (optionElement) optionElement.style.pointerEvents = "none"; // Disable clicking after vote

      try {
        const response = await fetch(`${apiUrl}/polls/vote`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ OptionId: optionId })
        });

        if (!response.ok) {
          console.error(`Failed to post vote: ${response.status} ${response.statusText}`);
          // You might want to show an error message to the user here
        }
        // Note: The SignalR 'newVote' event will trigger renderOptions if successful on server
      } catch (e) {
        console.error("Error casting vote:", e);
      } finally {
        // Re-enable clicking after a short delay, regardless of success/failure
        setTimeout(() => {
          if (optionElement) optionElement.style.pointerEvents = "auto";
        }, 1000); 
      }
    }

    // SignalR real-time update setup
    const connection = new signalR.HubConnectionBuilder()
      .withUrl(apiUrl) // Connects to your API's SignalR hub endpoint
      .withAutomaticReconnect() // Automatically try to reconnect
      .build();

    // Event listener for "newVote" from the SignalR hub
    connection.on("newVote", (pollId, optionId, newVotes) => {
      // console.log(`New vote received: PollId=${pollId}, OptionId=${optionId}, NewVotes=${newVotes}`);
      if (!currentPollData || pollId !== currentPollData.Id) return; // Ensure it's for the current poll

      const updatedOption = currentPollData.Options.find(o => o.Id === optionId);
      if (updatedOption) {
        updatedOption.Votes = newVotes; // Update local data
        renderOptions(); // Re-render to show updated votes
      }
    });

    // Start SignalR connection and fetch initial poll data
    (async () => {
      try {
        await connection.start();
        console.log("Połączono z SignalR.");
        fetchAndRenderPoll(); // Get initial poll data after connecting
      } catch (e) {
        console.error("Błąd połączenia z SignalR:", e);
        // Fallback: if SignalR fails, still try to load the poll once
        // so the poll data is at least displayed, even if not real-time.
        fetchAndRenderPoll(); 
      }
    })();
  </script>
</body>
</html>
